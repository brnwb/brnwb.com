import { mkdir, readFile, writeFile } from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";

const thisFile = fileURLToPath(import.meta.url);
const repoRoot = path.resolve(path.dirname(thisFile), "..");

const inputPath = path.join(repoRoot, "src", "data", "zepbound-weight.csv");
const outputPath = path.join(repoRoot, "web", "zepbound", "weights.generated.js");

const expectedColumns = ["date", "weight_lbs", "injection_date", "dose"];
const isoDatePattern = /^\d{4}-\d{2}-\d{2}$/;

function parseCSVLine(line) {
  const fields = [];
  let value = "";
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const ch = line[i];

    if (ch === '"') {
      if (inQuotes && line[i + 1] === '"') {
        value += '"';
        i++;
      } else {
        inQuotes = !inQuotes;
      }
      continue;
    }

    if (ch === "," && !inQuotes) {
      fields.push(value);
      value = "";
      continue;
    }

    value += ch;
  }

  if (inQuotes) {
    throw new Error("invalid CSV: unclosed quoted value");
  }

  fields.push(value);
  return fields;
}

function parseCSV(content) {
  const lines = content
    .replace(/^\uFEFF/, "")
    .split(/\r?\n/)
    .filter((line) => line.trim() !== "");

  if (lines.length < 2) {
    throw new Error("CSV must include a header and at least one row");
  }

  const headers = parseCSVLine(lines[0]).map((v) => v.trim());
  for (const column of expectedColumns) {
    if (!headers.includes(column)) {
      throw new Error(`missing required CSV column: ${column}`);
    }
  }

  const rows = [];
  for (let i = 1; i < lines.length; i++) {
    const rowNumber = i + 1;
    const fields = parseCSVLine(lines[i]);
    if (fields.length > headers.length) {
      throw new Error(`row ${rowNumber}: has more values than headers`);
    }

    const row = {};
    for (let columnIndex = 0; columnIndex < headers.length; columnIndex++) {
      const header = headers[columnIndex];
      row[header] = (fields[columnIndex] ?? "").trim();
    }
    rows.push({ rowNumber, row });
  }

  return rows;
}

function parseRequiredDate(value, fieldName, rowNumber) {
  if (value === "") {
    throw new Error(`row ${rowNumber}: ${fieldName} is required`);
  }
  if (!isoDatePattern.test(value)) {
    throw new Error(`row ${rowNumber}: invalid ${fieldName} "${value}" (expected YYYY-MM-DD)`);
  }
  return value;
}

function parseOptionalDate(value, fieldName, rowNumber) {
  if (value === "") {
    return null;
  }
  if (!isoDatePattern.test(value)) {
    throw new Error(`row ${rowNumber}: invalid ${fieldName} "${value}" (expected YYYY-MM-DD)`);
  }
  return value;
}

function parseOptionalWeight(value, rowNumber) {
  if (value === "") {
    return null;
  }

  const parsed = Number(value);
  if (!Number.isFinite(parsed)) {
    throw new Error(`row ${rowNumber}: invalid weight_lbs "${value}"`);
  }
  return parsed;
}

export async function generateZepboundData() {
  const content = await readFile(inputPath, "utf8");
  const parsedRows = parseCSV(content);

  const rows = parsedRows.map(({ rowNumber, row }) => {
    const date = parseRequiredDate(row.date, "date", rowNumber);
    const weight = parseOptionalWeight(row.weight_lbs, rowNumber);
    const injectionDate = parseOptionalDate(row.injection_date, "injection_date", rowNumber);
    const dose = row.dose === "" ? null : row.dose;

    if (dose !== null && injectionDate === null) {
      throw new Error(`row ${rowNumber}: dose requires injection_date`);
    }

    return {
      date,
      weight_lbs: weight,
      injection_date: injectionDate,
      dose,
    };
  });

  const output = `// Code generated by scripts/generate-zepbound-data.mjs. DO NOT EDIT.\n` +
    `export const rawRows = ${JSON.stringify(rows, null, 2)};\n`;

  await mkdir(path.dirname(outputPath), { recursive: true });
  await writeFile(outputPath, output, "utf8");

  return { count: rows.length, inputPath, outputPath };
}

function isDirectExecution() {
  if (!process.argv[1]) {
    return false;
  }
  return path.resolve(process.argv[1]) === thisFile;
}

if (isDirectExecution()) {
  generateZepboundData()
    .then(({ count, inputPath: inPath, outputPath: outPath }) => {
      console.log(`data: generated ${count} rows from ${path.relative(repoRoot, inPath)} -> ${path.relative(repoRoot, outPath)}`);
    })
    .catch((err) => {
      console.error("data: generation failed");
      console.error(err);
      process.exit(1);
    });
}
